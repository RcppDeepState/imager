<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>A loop-free Canny edge detector</title>

<script src="canny_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="canny_files/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="canny_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="canny_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="canny_files/bootstrap-3.3.5/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="canny_files/highlight/default.css"
      type="text/css" />
<script src="canny_files/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="canny_files/navigation-1.0/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">A loop-free Canny edge detector</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#step-i-denoising"><span class="toc-section-number">1</span> Step I: denoising</a></li>
<li><a href="#step-ii-computing-the-image-gradient-its-magnitude-and-angle"><span class="toc-section-number">2</span> Step II: computing the image gradient, its magnitude and angle</a></li>
<li><a href="#step-iii-cleaning-up-using-non-maxima-suppression"><span class="toc-section-number">3</span> Step III: cleaning up using non-maxima suppression</a></li>
<li><a href="#step-iv-hysteresis"><span class="toc-section-number">4</span> Step IV: hysteresis</a></li>
</ul>
</div>

<p><a href="http://sites.google.com/site/simonbarthelme">Simon Barthelmé</a> (GIPSA-lab, CNRS)</p>
<p>The Canny edge detector is one of the canonical algorithms of computer vision. All implementations I’ve seen use several loops over pixel values. Loops in R are extremely slow, but on the other hand <em>vectorised</em> operations can be pretty fast. In this tutorial I’ll explain how to build a vectorised implementation of the Canny edge detector, in a functional programming style.</p>
<p>I’ll follow the structure of the algorithm as explained <a href="https://en.wikipedia.org/wiki/Canny_edge_detector">on the Wikipedia page</a>.</p>
<div id="step-i-denoising" class="section level1">
<h1><span class="header-section-number">1</span> Step I: denoising</h1>
<p>Noise in the image can cause illusory edges to be detected. The traditional recommendation is Gaussian filtering, which is easy enough:</p>
<pre class="r"><code>library(imager)
im &lt;- grayscale(boats) %&gt;% isoblur(2) #2 pix. blur</code></pre>
<p>(NB: other filters may actually perform better here, for example the median filter).</p>
</div>
<div id="step-ii-computing-the-image-gradient-its-magnitude-and-angle" class="section level1">
<h1><span class="header-section-number">2</span> Step II: computing the image gradient, its magnitude and angle</h1>
<p>The next step is to compute an image gradient, which boils down to:</p>
<pre class="r"><code>gr &lt;- imgradient(im,&quot;xy&quot;)
plot(gr,layout=&quot;row&quot;)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-2-1.png" width="624" /></p>
<p>The gradient has two components (the image derivatives along <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>), and is stored as an image list, with two components named “x” and “y”.</p>
<p>We can compute the gradient magnitude via:</p>
<pre class="r"><code>mag &lt;- with(gr,sqrt(x^2+y^2))
plot(mag)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-3-1.png" width="624" /></p>
<p>The Canny edge detector is essentially a cleaned-up version of the above picture.</p>
<p>The gradient angle determines the local orientation of image edges:</p>
<pre class="r"><code>ang &lt;- with(gr,atan2(y,x))
plot(ang)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-4-1.png" width="624" /></p>
<p>The above figure looks interesting but is hard to read. One of the issues is that an angular variable (taking values in <span class="math inline">\(-\pi,\pi\)</span> is mapped to a linear scale (black and white correspond to <span class="math inline">\(-\pi\)</span> and <span class="math inline">\(\pi\)</span>, but <span class="math inline">\(-\pi\)</span> and <span class="math inline">\(\pi\)</span> correspond to the same angle). Here it is on a circular colour scale:</p>
<pre class="r"><code>cs &lt;- scales::gradient_n_pal(c(&quot;red&quot;,&quot;darkblue&quot;,&quot;lightblue&quot;,&quot;red&quot;),c(-pi,-pi/2,pi/2,pi))
plot(ang,colourscale=cs,rescale=FALSE)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-5-1.png" width="624" /></p>
<p>For a better way of visualising image gradients, see <a href="gradient_field.html">here</a>.</p>
</div>
<div id="step-iii-cleaning-up-using-non-maxima-suppression" class="section level1">
<h1><span class="header-section-number">3</span> Step III: cleaning up using non-maxima suppression</h1>
<p>The gradient magnitude we plotted above is blurry, and if we threshold it directly we’ll see that some pixels near edges are also labelled as being edges:</p>
<pre class="r"><code>threshold(mag) %&gt;% plot</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-6-1.png" width="624" /></p>
<p>The goal on non-maxima suppression is to eliminate such false positives. To do so we set to 0 all pixels in the gradient magnitude image that are not local maxima along the direction of the gradient. In a C++ implementation you would loop through all the pixels, and check that all the pixels have higher values than their two neighbours in the direction of the gradient. In R that would take ages, so we need to find a way to vectorise that operation. The solution is to use interpolation as a our main vectorised operation. Interpolation returns a list of image values at a set of locations. What we’ll do is take the whole set of pixels, compute a corresponding set of neighbouring locations along the gradients, and see what the image values are at the new locations. For example, here we go see what’s what along the gradient:</p>
<pre class="r"><code>#Going along the (normalised) gradient
#Xc(im) is an image containing the x coordinates of the image
nX &lt;- Xc(im) + gr$x/mag 
nY &lt;- Yc(im) + gr$y/mag
#nX and nY are not integer values, so we can&#39;t use them directly as indices.
#We can use interpolation, though:
val.fwd &lt;- interp(mag,data.frame(x=as.vector(nX),y=as.vector(nY)))</code></pre>
<p>We can naturally also go backwards along the gradient:</p>
<pre class="r"><code>nX &lt;- Xc(im) - gr$x/mag 
nY &lt;- Yc(im) - gr$y/mag
val.bwd &lt;- interp(mag,data.frame(x=as.vector(nX),y=as.vector(nY)))</code></pre>
<p>Given these two sets of values, non-maxima suppression comes down to killing all values that aren’t larger than their two neighbours along the flow:</p>
<pre class="r"><code>throw &lt;- (mag &lt; val.bwd) | (mag &lt; val.fwd)
mag[throw] &lt;- 0
plot(mag)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-9-1.png" width="624" /></p>
</div>
<div id="step-iv-hysteresis" class="section level1">
<h1><span class="header-section-number">4</span> Step IV: hysteresis</h1>
<p>At this stage we’re beginning to see some nice outlines, but the ultimate goal is to classify each pixel as edge/non-edge, which means picking a threshold. Instead of picking a single threshold, Canny suggested picking a double threshold <span class="math inline">\(t_1,t_2\)</span>, with <span class="math inline">\(t_1 &lt; t_2\)</span>, where</p>
<ul>
<li>points with magnitudes above <span class="math inline">\(t_2\)</span> are called “strong edges”</li>
<li>points with magnitudes above <span class="math inline">\(t_1\)</span> are called “weak edges”</li>
</ul>
<pre class="r"><code>#strong threshold
t2 &lt;- quantile(mag,.96)
#weak threshold 
t1 &lt;- quantile(mag,.90)
layout(t(1:2))

strong &lt;- mag&gt;t2
plot(strong,main=&quot;Initial set of strong edges&quot;)
weak &lt;- mag %inr% c(t1,t2)
plot(weak,main=&quot;Initial set of weak edges&quot;)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-10-1.png" width="624" /></p>
<p>Weak edges have a high chance of being false positives, but less so if there’s a strong edge somewhere nearby, because edges are usually continuous.</p>
<p>Hysteresis rescues such weak edges progressively. The usual implementation is iterative. First, we put all the strong edges in a stack (or queue). Then, we pop the first strong edge off the stack, look at all its neighbours, and if any of these neighbours is a weak edge you rescue it by labelling it as strong and adding it to the stack. Then we move on to the next item on the stack (or queue). When we run out of items in the queue we’re done.</p>
<pre class="r"><code>hyst.loop &lt;- function(strong,weak)
    {
        #We make the queue a list so that it can grow or shrink relatively fast
        queue &lt;- which(strong==1) %&gt;% as.list
        max.x &lt;- width(strong)
        max.y &lt;- height(strong)
        while (length(queue)&gt;0)
            {
                ind &lt;- queue[[1]]
                #get (x,y) coordinates of the current point
                cc &lt;- coord.index(strong,ind)
                #explore the neighbourhood
                for (nx in (cc$x+c(-1,0,1)))
                {
                    for (ny in (cc$y+c(-1,0,1)))
                    {
                        #we have to mind boundary conditions
                        if (nx &gt; 0 &amp;&amp; nx &lt;= max.x &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= max.y)
                        {
                            if (at(weak,nx,ny)==TRUE)
                            {
                                at(weak,nx,ny) &lt;- FALSE
                                at(strong,nx,ny) &lt;- TRUE
                                queue[[length(queue)+1]] &lt;- index.coord(strong,data.frame(x=nx,y=ny))
                            }
                        }
                    }
                }
                queue[[1]] &lt;- NULL
            }
        strong
    }

canny &lt;- hyst.loop(strong,weak)
plot(canny,main=&quot;Edges after hystereris&quot;)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-11-1.png" width="624" /></p>
<p>R is impractically slow for such a process (try running hyst.loop on a large image).</p>
<p>We can do much better by using morphological dilation as our computational primitive. <a href="https://en.wikipedia.org/wiki/Dilation_(morphology)">Morphological dilation</a> takes a B&amp;W image and expands the set of white pixels by using a “structuring element”. In the simplest case the structuring element is a square and dilation corresponds to a kind of convolution: we move the square around, and we label the central element white if there is another white pixel in the square. This operation is called “grow” in imager, when applied to pixel sets. See <a href="morphology.html">here</a> for more on morphology. Here it is at work on a small noise image:</p>
<pre class="r"><code>px &lt;- imnoise(100,100) &gt; 1
layout(t(1:2))
plot(px,&quot;Original&quot;)
plot(grow(px,3),&quot;Dilated Set&quot;)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-12-1.png" width="624" /></p>
<p>Morphological dilation gives us a way of implementing hysteresis. We start from the set of strong edges, expand it with dilation, and check its overlap with the set of weak-edges. Any points in the overlap can now be labelled “strong”:</p>
<pre class="r"><code>overlap &lt;- grow(strong,3) &amp; weak 
strong.new &lt;- strong | overlap
plot(strong.new,main=&quot;New set of strong edges&quot;)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-13-1.png" width="624" /></p>
<pre class="r"><code>delta &lt;- sum(strong.new)-sum(strong)
delta</code></pre>
<pre><code>## [1] 188</code></pre>
<p>We have labelled 202 formerly weak edges as strong. There’s no reason to stop here: we can repeat the operation until the set of weak edges stops growing. The hysteresis operation is thus a fixed point iteration, an computation we go on doing until the results stop changing. The package “fixedpoint” provides a convenient mechanism for turning a function into a fixed point iteration.</p>
<pre class="r"><code>#run devtools::install_github(&quot;dahtah/fixedpoints&quot;)
library(fixedpoints)

#Example of a fixed point iteration:
#divide a number by 2 until the result doesn&#39;t change
f &lt;- function(x) x/2
g &lt;- fp(f)
g(3) #Run the fixed point iteration from 3.</code></pre>
<pre><code>## Result after 29 iterations. Converged:  TRUE.
## [1] 5.587935e-09</code></pre>
<pre class="r"><code>g(0) </code></pre>
<pre><code>## Result after 1 iterations. Converged:  TRUE.
## [1] 0</code></pre>
<p>In our case the mapping to iterate is the “expansion, relabelling” operation we had above:</p>
<pre class="r"><code>#ws is a list containing two fields, &quot;weak&quot; and &quot;strong&quot;
#which are images where all pixels with value 1 are &quot;weak edges&quot; (resp. strong)
#the function expands the set of strong pixels via dilation and overlap
#and returns the expanded strong set and the (shrunk) weak set
expandStrong &lt;- function(ws)
    {
        overlap &lt;- grow(ws$strong,3) &amp; ws$weak
        ws$strong[overlap] &lt;- TRUE
        ws$weak[overlap] &lt;- FALSE
        ws
    }


#hystFP is a new function that will call expandStrong repeatedly until
#the weak and strong sets don&#39;t change anymore
hystFP &lt;- fp(expandStrong)

#Call hystFP
out &lt;- list(strong=strong,weak=weak) %&gt;% hystFP
out</code></pre>
<pre><code>## Result after 71 iterations. Converged:  TRUE.
## $strong
## Pixel set of size 5587. Width: 256 pix Height: 384 pix Depth: 1 Colour channels: 1 
## 
## $weak
## Pixel set of size 4244. Width: 256 pix Height: 384 pix Depth: 1 Colour channels: 1</code></pre>
<pre class="r"><code>canny &lt;- out$strong
plot(canny,main=&quot;Canny edges&quot;)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-15-1.png" width="624" /></p>
<p>Of course, in a way we are cheating here: the fixed point iteration is really a loop. But instead of looping over each pixel (which is slow, because there are many pixels), we run a global computation on all pixels, 70 times, which is much faster. The fact that it takes 70 iterations to rescue all the weak edges tells us that, in this image at least, some weak edges are hard to reach: there is a connection between the initial set of strong edges and some far-away weak edges. A better computational primitive in this case is the bucket fill (also called the “flood fill”), which you probably know from using your favourite image editor.</p>
<pre class="r"><code>im1 &lt;- as.cimg(function(x,y) x == 50,100,100)
layout(t(1:2))
plot(im1,main=&quot;Bucket fill initialised at red point&quot;)
points(80,80,col=&quot;red&quot;)
bucketfill(im1,80,80,color=1,high_connex=TRUE) %&gt;% plot(main=&quot;Result&quot;)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-16-1.png" width="768" /></p>
<p>The bucketfill has a tolerance parameter, which sets a stopping criterion: if nearby pixels are more than “sigma” apart in value, they won’t be filled. The trick will consist in starting a bucket fill inside a strong region, and painting nearby weak pixels as strong. If we do this from all strong regions, we’ll have rescued all the weak edges that need to be rescued. split_connected splits a pixel set into its connected regions:</p>
<pre class="r"><code>pxs &lt;- split_connected(strong,high_connectivity=TRUE)
length(pxs)</code></pre>
<pre><code>## [1] 125</code></pre>
<p>Each element in pxs is a pixel set representing a set of connected strong edge pixels.</p>
<p>We need seed pixels from each region, which we can collect using purrr’s map function:</p>
<pre class="r"><code>#Collect seed pixels and plot their location
plot(strong)
library(purrr)
map_df(pxs,~ where(.)[1,]) %$% points(x,y,col=&quot;red&quot;)</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-18-1.png" width="624" /></p>
<p>For the bucket fill trick to work we need to be able to spread the value of strong pixels to their weak neighbour (but not elsewhere). We assign different values to strong and weak pixels:</p>
<pre class="r"><code>v &lt;- as.cimg(strong)
v[weak==1] &lt;- .9 #Strong pixels have value 1, weak .9, and the rest are 0.</code></pre>
<p>Finally we need to go through the list of seed pixels, and apply bucket fill every time. We could write a loop, but to keep with the functional style we have used so far, we’ll cast this operation as a <em>fold</em>, using <em>reduce</em> from the <a href="https://github.com/hadley/purrr">purrr</a> package. <em>reduce</em> takes a function of two arguments (an accumulator and an item), and reduces a list to a single item by accumulating. It’s best illustrated by example:</p>
<pre class="r"><code>library(purrr)
add &lt;- function(l) reduce(l,function(acc,item) acc+item,.init=0)
add(1:3) #equals sum(1:3)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>mult &lt;- function(l) reduce(l,function(acc,item) acc*item,.init=1)
mult(1:3) #equals prod(1:3)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>#put the three colour channels side-by-side
imsplit(boats,&quot;c&quot;) %&gt;% reduce(function(acc,l) imappend(list(acc,l),&quot;x&quot;)) %&gt;% plot</code></pre>
<p><img src="canny_files/figure-html/unnamed-chunk-20-1.png" width="624" /></p>
<pre class="r"><code>#Gives a set of initial locations for the bucket fill
fillInit &lt;- function(strong)
{
    pxs &lt;- split_connected(strong,high_connectivity=TRUE)
    map_df(pxs,~ where(.)[1,])
}

#Starts a fill at each successive location, and accumulates the results
rescueFill &lt;- function(strong,weak)
    {
        v &lt;- as.cimg(strong)
        v[weak] &lt;- .9
        loc &lt;- fillInit(strong)
        #Transform the data.frame into a list of locations
        loc &lt;- transpose(loc)
        #Fold
        out &lt;- reduce(loc,function(v,l) bucketfill(v,l$x,l$y,color=1,sigma=.1,high=TRUE),
                      .init=v)
        out==1
    }

canny2 &lt;- rescueFill(strong,weak)
all.equal(canny,canny2)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>The second function is much faster, at least on this image (for this particular choice of thresholds):</p>
<pre class="r"><code>system.time(hystFP(list(strong=strong,weak=weak)))</code></pre>
<pre><code>##    user  system elapsed 
##   0.460   0.008   0.468</code></pre>
<pre class="r"><code>system.time(rescueFill(strong,weak))</code></pre>
<pre><code>##    user  system elapsed 
##   0.183   0.000   0.183</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
