<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>imager: an R package for image processing</title>

<script src="imager_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="imager_files/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="imager_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="imager_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="imager_files/bootstrap-3.3.5/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="imager_files/highlight/default.css"
      type="text/css" />
<script src="imager_files/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="imager_files/navigation-1.0/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">imager: an R package for image processing</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#quick-start"><span class="toc-section-number">1</span> Quick start</a></li>
<li><a href="#loading-and-saving"><span class="toc-section-number">2</span> Loading and saving</a></li>
<li><a href="#displaying-images-and-videos"><span class="toc-section-number">3</span> Displaying images and videos</a></li>
<li><a href="#how-images-are-represented"><span class="toc-section-number">4</span> How images are represented</a></li>
<li><a href="#coordinates"><span class="toc-section-number">5</span> Coordinates</a></li>
<li><a href="#the-cimg-class"><span class="toc-section-number">6</span> The cimg class</a></li>
<li><a href="#image-lists"><span class="toc-section-number">7</span> Image lists</a></li>
<li><a href="#splitting-and-concatenating-images"><span class="toc-section-number">8</span> Splitting and concatenating images</a></li>
<li><a href="#split-apply-combine"><span class="toc-section-number">9</span> Split, apply, combine</a></li>
<li><a href="#sub-images-pixel-neighbourhoods-etc."><span class="toc-section-number">10</span> Sub-images, pixel neighbourhoods, etc.</a></li>
<li><a href="#denoising"><span class="toc-section-number">11</span> Denoising</a></li>
<li><a href="#colour-spaces"><span class="toc-section-number">12</span> Colour spaces</a></li>
<li><a href="#resizing-rotation-etc."><span class="toc-section-number">13</span> Resizing, rotation, etc.</a></li>
<li><a href="#warping"><span class="toc-section-number">14</span> Warping</a></li>
<li><a href="#lagged-operators"><span class="toc-section-number">15</span> Lagged operators</a></li>
<li><a href="#filtering"><span class="toc-section-number">16</span> Filtering</a></li>
<li><a href="#ffts-and-the-periodicsmooth-decomposition"><span class="toc-section-number">17</span> FFTs and the periodic/smooth decomposition</a></li>
<li><a href="#morphology"><span class="toc-section-number">18</span> Morphology</a></li>
</ul>
</div>

<p><a href="http://sites.google.com/site/simonbarthelme">Simon Barthelmé</a> (GIPSA-lab, CNRS)</p>
<p>This documentation covers imager version 0.20. Some functions may be unavailable in older versions. Follow imager development on <a href="https://github.com/dahtah/imager">github</a>.</p>
<p>Beginners: have a look at the <a href="gettingstarted.html">tutorial</a> first.</p>
<div id="quick-start" class="section level1">
<h1><span class="header-section-number">1</span> Quick start</h1>
<p>Here’s an example of imager in action:</p>
<pre class="r"><code>library(imager)


file &lt;- system.file(&#39;extdata/parrots.png&#39;,package=&#39;imager&#39;)
#system.file gives the full path for a file that ships with a R package
#if you already have the full path to the file you want to load just run:
#im &lt;- load.image(&quot;/somedirectory/myfile.png&quot;)
im &lt;- load.image(file)

plot(im) #Parrots!</code></pre>
<p><img src="imager_files/figure-html/quickstart-1.jpeg" width="624" /></p>
<pre class="r"><code>im.blurry &lt;- isoblur(im,10) #Blurry parrots!
plot(im.blurry)</code></pre>
<p><img src="imager_files/figure-html/quickstart-2.jpeg" width="624" /></p>
<pre class="r"><code>im.xedges &lt;- deriche(im,2,order=2,axis=&quot;x&quot;) #Edge detector along x-axis
plot(im.xedges)</code></pre>
<p><img src="imager_files/figure-html/quickstart-3.jpeg" width="624" /></p>
<pre class="r"><code>im.yedges &lt;- deriche(im,2,order=2,axis=&quot;y&quot;) #Edge detector along y-axis
plot(im.yedges)</code></pre>
<p><img src="imager_files/figure-html/quickstart-4.jpeg" width="624" /></p>
<pre class="r"><code>#Chain operations using the pipe operator (from magrittr)
deriche(im,2,order=2,axis=&quot;x&quot;) %&gt;% deriche(2,order=2,axis=&quot;y&quot;) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/quickstart-5.jpeg" width="624" /></p>
<pre class="r"><code>#Another example of chaining: image gradient along x and y axes
layout(matrix(1:2,1,2));
grayscale(im) %&gt;% get_gradient(axes=&quot;xy&quot;) %&gt;% l_ply(plot)</code></pre>
<p><img src="imager_files/figure-html/quickstart2-1.jpeg" width="1152" /></p>
<pre class="r"><code>#If ffmpeg is present, we can load videos as well:
tennis &lt;- load.image(system.file(&#39;extdata/tennis_sif.mpeg&#39;,package=&#39;imager&#39;))

plot(tennis,frame=1)
plot(tennis,frame=5)</code></pre>
<p><img src="imager_files/figure-html/quickstart2-2.jpeg" width="1152" /></p>
<p>In the next example, we convert the video to grayscale, run a motion detector, and combine both videos to display them side-by-side:</p>
<pre class="r"><code>tennis.g &lt;- grayscale(tennis)
motion &lt;- deriche(tennis.g,1,order=1,axis=&quot;z&quot;)^2 #Differentiate along z axis and square
combined &lt;- list(motion/max(motion),tennis.g/max(tennis.g)) %&gt;% imappend(&quot;x&quot;) #Paste the two videos together</code></pre>
<p>In an interactive session you can run play(combined) to view the results.</p>
<video width="1152"  controls loop>
<source src="imager_files/figure-html/animate-.webm" />
<p>
video of chunk animate
</p>
</video>
</div>
<div id="loading-and-saving" class="section level1">
<h1><span class="header-section-number">2</span> Loading and saving</h1>
<p>Use load.image and save.image. imager supports PNG, JPEG and BMP natively. If you need to access images in other formats you’ll need to install <a href="http://www.imagemagick.org/script/binary-releases.php">ImageMagick</a> for images, and <a href="http://ffmpeg.org/download.html">ffmpeg</a> for videos.</p>
<pre class="r"><code>file &lt;- system.file(&#39;extdata/parrots.png&#39;,package=&#39;imager&#39;)
parrots &lt;- load.image(file)
#The file format is defined by the extension. Here we save as JPEG
imager::save.image(parrots,&quot;/tmp/parrots.jpeg&quot;)
#We call imager::save.image to avoid ambiguity, as base R already has a save.image function </code></pre>
<p>You can load files from your hard drive or from a URL. Loading from URLs is useful when scraping web pages, for example. The following piece of code searches for pictures of parrots (using the rvest package), then loads the first one it finds</p>
<pre class="r"><code>library(rvest)
#Run a search query (returning html content)
search &lt;- read_html(&quot;https://www.google.com/search?site=&amp;tbm=isch&amp;q=parrot&quot;)

#Grab all &lt;img&gt; tags, get their &quot;src&quot; attribute, a URL to an image
urls &lt;- search %&gt;% html_nodes(&quot;img&quot;) %&gt;% html_attr(&quot;src&quot;) #Get urls of parrot pictures

#Load the first one
load.image(urls[1]) %&gt;% plot()</code></pre>
<p><img src="imager_files/figure-html/loading_parrots-1.jpeg" width="624" /></p>
</div>
<div id="displaying-images-and-videos" class="section level1">
<h1><span class="header-section-number">3</span> Displaying images and videos</h1>
<p>To get a standard R plot use the plot function:</p>
<pre class="r"><code>plot(parrots)</code></pre>
<p><img src="imager_files/figure-html/plotting-1.jpeg" width="624" /></p>
<pre class="r"><code>plot(tennis,frame=1) </code></pre>
<p><img src="imager_files/figure-html/plotting-2.jpeg" width="624" /></p>
<p>In addition imager provides display() (for images) and play() (for videos), which are much faster C++ functions for quickly viewing your results. If you’d like to use an external viewer, you can save the image to a temporary file:</p>
<pre class="r"><code>tmp &lt;- tempfile(fileext=&quot;.png&quot;) #Open temp. file
imager::save.image(boats,tmp) #Save image to temp. file
#Call &quot;eog [temp file]&quot; to open in external viewer (Linux only)
paste(&quot;eog&quot;,tmp) %&gt;% system
#On a mac: try system(paste(&quot;open&quot;,tmp))
unlink(tmp) #Delete temp. file</code></pre>
</div>
<div id="how-images-are-represented" class="section level1">
<h1><span class="header-section-number">4</span> How images are represented</h1>
<p>Images are represented as 4D numeric arrays, which is consistent with CImg’s storage standard (it is unfortunately inconsistent with other R libraries, like spatstat, but converting between representations is easy). The four dimensions are labelled x,y,z,c. The first two are the usual spatial dimensions, the third one will usually correspond to depth or time, and the fourth one is colour. Remember the order, it will be used consistently in imager. If you only have grayscale images then the two extra dimensions are obviously pointless, but they won’t bother you much. Your objects will still be officially 4 dimensional, with two trailing flat dimensions. Pixels are stored in the following manner: we scan the image beginning at the upper-left corner, along the x axis. Once we hit the end of the scanline, we move to the next line. Once we hit the end of the screen, we move to the next frame (increasing z) and repeat the process. If we have several colour channels, then once we’re done with the first colour channel we move to the next one. All in all the different dimensions are represented in the x,y,z,c order. In R the object is represented as a 4D array. Here’s an example with a grayscale image:</p>
<pre class="r"><code>parrots &lt;- load.example(&#39;parrots&#39;)
gray.parrots &lt;- grayscale(parrots)
dim(gray.parrots)</code></pre>
<pre><code>[1] 768 512   1   1</code></pre>
<p>and a colour image:</p>
<pre class="r"><code>dim(parrots)</code></pre>
<pre><code>[1] 768 512   1   3</code></pre>
<p>and finally a video, also in colour:</p>
<pre class="r"><code>dim(tennis)</code></pre>
<pre><code>[1] 352 240 150   3</code></pre>
</div>
<div id="coordinates" class="section level1">
<h1><span class="header-section-number">5</span> Coordinates</h1>
<p>CImg uses standard image coordinates: the origin is at the top left corner, with the x axis pointing right and the y axis pointing <em>down</em>. imager uses the same coordinate system, except the origin is now (1,1) and not (0,0) (the reason being that R indices start at 1 and not at 0). The number of pixels along the x axis is called the width, along the y axis it’s height, along the z axis it’s depth and finally the number of colour channels is called “spectrum”.</p>
<pre class="r"><code>width(parrots)</code></pre>
<pre><code>[1] 768</code></pre>
<pre class="r"><code>height(parrots)</code></pre>
<pre><code>[1] 512</code></pre>
<pre class="r"><code>depth(parrots)</code></pre>
<pre><code>[1] 1</code></pre>
<pre class="r"><code>spectrum(parrots)</code></pre>
<pre><code>[1] 3</code></pre>
</div>
<div id="the-cimg-class" class="section level1">
<h1><span class="header-section-number">6</span> The cimg class</h1>
<p>Imager uses the “cimg” class for its images. “cimg” is just a regular 4d array with an S3 class tacked on so we can have custom plot, print, etc. To promote an array to a “cimg” object, use as.cimg:</p>
<pre class="r"><code>noise &lt;- array(runif(5*5*5*3),c(5,5,5,3)) #5x5 pixels, 5 frames, 3 colours. All noise
noise &lt;- as.cimg(noise)</code></pre>
<p>You can treat the object as you would any other array:</p>
<pre class="r"><code>#Arithmetic
sin(noise) + 3*noise </code></pre>
<pre><code>Image. Width: 5 pix Height: 5 pix Depth: 5 Colour channels: 3 </code></pre>
<pre class="r"><code>#Subsetting
noise[,,,1] #First colour channel</code></pre>
<pre><code>, , 1

          [,1]       [,2]      [,3]       [,4]        [,5]
[1,] 0.3510337 0.76994033 0.1585224 0.85659146 0.345474361
[2,] 0.8456644 0.01383741 0.9971350 0.69984376 0.388089864
[3,] 0.3275034 0.89027737 0.6519898 0.54386820 0.907249955
[4,] 0.3949027 0.03133751 0.3398497 0.21482575 0.006593775
[5,] 0.2303667 0.42780621 0.7485127 0.06081203 0.419723301

, , 2

          [,1]      [,2]      [,3]       [,4]      [,5]
[1,] 0.9190668 0.8040562 0.2477229 0.18348958 0.3005642
[2,] 0.7214234 0.9532363 0.4843048 0.80618905 0.7443933
[3,] 0.3884877 0.4896235 0.1195527 0.09582635 0.3718278
[4,] 0.6626700 0.3609153 0.1333640 0.64431858 0.9894917
[5,] 0.7536416 0.4578405 0.9426645 0.03182711 0.3771937

, , 3

           [,1]        [,2]      [,3]      [,4]      [,5]
[1,] 0.06709956 0.994025144 0.5526753 0.2698329 0.5989443
[2,] 0.69054710 0.698176055 0.7654785 0.8453901 0.1252817
[3,] 0.64665840 0.007431889 0.1556904 0.6569562 0.5875018
[4,] 0.02632171 0.538871856 0.5511799 0.6785020 0.7733848
[5,] 0.58920388 0.856742959 0.6064965 0.7258797 0.3654295

, , 4

          [,1]      [,2]      [,3]       [,4]       [,5]
[1,] 0.2001784 0.9162113 0.6247090 0.07353605 0.01083378
[2,] 0.3194382 0.7227267 0.6255889 0.79507656 0.20019494
[3,] 0.8530176 0.8208716 0.6750365 0.98036421 0.79974117
[4,] 0.5475812 0.5518732 0.8364710 0.57146296 0.05832274
[5,] 0.1842463 0.4753840 0.5273422 0.78843016 0.05364201

, , 5

          [,1]      [,2]      [,3]       [,4]       [,5]
[1,] 0.4514860 0.1975269 0.8431716 0.62626085 0.26102108
[2,] 0.2873308 0.9433144 0.9796437 0.55679229 0.10640043
[3,] 0.1747636 0.9531210 0.9684121 0.06136671 0.07005774
[4,] 0.4573823 0.6753696 0.0684578 0.28194490 0.34898283
[5,] 0.6432527 0.4418153 0.2459070 0.97942470 0.91352755</code></pre>
<pre class="r"><code>dim(noise[1:4,,,] )</code></pre>
<pre><code>[1] 4 5 5 3</code></pre>
<p>which makes life easier if you want to use ggplot2 for plotting (see <a href="getting_started.html">tutorial</a>).</p>
<p>You can also convert matrices to cimg objects:</p>
<pre class="r"><code>matrix(1,10,10) %&gt;% as.cimg</code></pre>
<pre><code>Image. Width: 10 pix Height: 10 pix Depth: 1 Colour channels: 1 </code></pre>
<p>and vectors:</p>
<pre class="r"><code>1:9 %&gt;% as.cimg</code></pre>
<pre><code>Image. Width: 3 pix Height: 3 pix Depth: 1 Colour channels: 1 </code></pre>
<p>which tries to guess what sort of image dimensions you want (see <a href="getting_started.html">tutorial</a>).</p>
<p>The reverse is possible as well: if you have a data.frame with columns x,y,z,cc,value, you can turn it into a cimg object:</p>
<pre class="r"><code>df &lt;- expand.grid(x=1:10,y=1:10,z=1,cc=1)
mutate(df,value=cos(sin(x+y)^2)) %&gt;% as.cimg</code></pre>
<pre><code>Image. Width: 10 pix Height: 10 pix Depth: 1 Colour channels: 1 </code></pre>
<p>By default as.cimg.data.frame will try to guess image size from the input. You can also be specific by setting the “dims” argument explicitly:</p>
<pre class="r"><code>mutate(df,value=cos(sin(x+y)^2)) %&gt;% as.cimg(dims=c(10,10,1,1))</code></pre>
<pre><code>Image. Width: 10 pix Height: 10 pix Depth: 1 Colour channels: 1 </code></pre>
<p>The reverse is possible as well: you can convert a cimg object to a data.frame</p>
<pre class="r"><code>head(as.data.frame(parrots))</code></pre>
<pre><code>  x y cc     value
1 1 1  1 0.4549020
2 2 1  1 0.4588235
3 3 1  1 0.4705882
4 4 1  1 0.4666667
5 5 1  1 0.4705882
6 6 1  1 0.4705882</code></pre>
<p>or to an array, vector or matrix</p>
<pre class="r"><code>head(as.array(parrots))</code></pre>
<pre><code>[1] 0.4549020 0.4588235 0.4705882 0.4666667 0.4705882 0.4705882</code></pre>
<pre class="r"><code>head(as.vector(parrots))</code></pre>
<pre><code>[1] 0.4549020 0.4588235 0.4705882 0.4666667 0.4705882 0.4705882</code></pre>
<pre class="r"><code>grayscale(parrots) %&gt;% as.matrix %&gt;% dim</code></pre>
<pre><code>[1] 768 512</code></pre>
</div>
<div id="image-lists" class="section level1">
<h1><span class="header-section-number">7</span> Image lists</h1>
<p>Many functions in imager produce lists of image as output (see below). These are given the “imlist” class, e.g. imgradient returns:</p>
<pre class="r"><code>imgradient(parrots,&quot;xy&quot;) %&gt;% class</code></pre>
<pre><code>[1] &quot;imlist&quot; &quot;list&quot;  </code></pre>
<p>The imlist class comes with a few convenience functions, for example:</p>
<pre class="r"><code>imgradient(parrots,&quot;xy&quot;) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-5-1.jpeg" width="624" /></p>
<p>and:</p>
<pre class="r"><code>imgradient(parrots,&quot;xy&quot;) %&gt;% as.data.frame %&gt;% head</code></pre>
<pre><code>  im x y cc        value
1  x 1 1  1  0.001386484
2  x 2 1  1  0.006120236
3  x 3 1  1  0.002198667
4  x 4 1  1 -0.001722901
5  x 5 1  1  0.002535085
6  x 6 1  1 -0.001287949</code></pre>
<p>where the “im” column indexes the image in the list.</p>
<p>To make an image list from a list, use “imlist”</p>
<pre class="r"><code>list(a=parrots,b=3*parrots) %&gt;% imlist</code></pre>
<pre><code>Image list of size 2 </code></pre>
</div>
<div id="splitting-and-concatenating-images" class="section level1">
<h1><span class="header-section-number">8</span> Splitting and concatenating images</h1>
<p>One often needs to perform separate computations on each channel of an image, or on each frame, each line, etc. This can be achieved using a loop or more conveniently using imsplit:</p>
<pre class="r"><code>imsplit(parrots,&quot;c&quot;) #A list with three elements corresponding to the three channels</code></pre>
<pre><code>Image list of size 3 </code></pre>
<pre class="r"><code>imsplit(parrots,&quot;c&quot;) %&gt;% laply(mean) #Mean pixel value in each channel</code></pre>
<pre><code>[1] 0.4771064 0.4297881 0.2972314</code></pre>
<pre class="r"><code>imsplit(parrots,&quot;x&quot;) %&gt;% laply(mean) %&gt;% head #Mean pixel value in each line (across all channels)</code></pre>
<pre><code>[1] 0.3666948 0.3682700 0.3697508 0.3705525 0.3707925 0.3708410</code></pre>
<p>imsplit contains an additional argument, called “nb”. When “nb” is positive imsplit cuts the image into “nb” chunks, along the axis “axis”:</p>
<pre class="r"><code>imsplit(parrots,&quot;x&quot;,4) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-8-1.jpeg" width="624" /></p>
<pre class="r"><code>imsplit(parrots,&quot;y&quot;,3) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-8-2.jpeg" width="624" /></p>
<p>When “nb” is negative, “nb” pixels defines the chunk size:</p>
<pre class="r"><code>imsplit(parrots,&quot;x&quot;,-250) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-9-1.jpeg" width="624" /></p>
<p>That last panel looks crummy because it’s a long-and-thin image stretched into a square.</p>
<p>The inverse operation to imsplit is called imappend: it takes a list of images and concatenates them along the dimension of your choice.</p>
<pre class="r"><code>#Sample functions and turn them into separate R,G,B channels
R &lt;- as.cimg(function(x,y) sin(cos(3*x*y)),100,100)
G &lt;- as.cimg(function(x,y) sin(cos(3*x*y + pi/2)),100,100)
B &lt;- as.cimg(function(x,y) exp(-.03*x),100,100)
trippy &lt;- imappend(list(R,G,B),&quot;c&quot;) #Bind the three channels into one image
plot(trippy)</code></pre>
<p><img src="imager_files/figure-html/imappend-1.jpeg" width="624" /></p>
</div>
<div id="split-apply-combine" class="section level1">
<h1><span class="header-section-number">9</span> Split, apply, combine</h1>
<p>Often what one wants to do is to split the image along a certain axis (e.g. colour), apply a transformation separately and recombine the result. iiply does that:</p>
<pre class="r"><code>iiply(parrots,&quot;c&quot;,function(v) v/max(v))  %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/iiply-1.jpeg" width="624" /></p>
<pre class="r"><code>#Same thing but longer:
#imsplit(parrots,&quot;c&quot;) %&gt;% llply(function(v) v/max(v) %&gt;% imappend(&quot;c&quot;) %&gt;% plot</code></pre>
<p>The code above separates colour channels, applies a normalisation and recombines the result into an image. Following the same convention used by plyr, imager also defines ilply (which splits, applies and returns a list), idply (which splits, applies and returns a data.frame) and liply (which applies, combines and returns an image).</p>
<p>Another way to combine after a split is to take the mean result, or a product, etc (the same way layers are combined in an image editing program). You can do this using shortcuts defined by imager:</p>
<pre class="r"><code>imsplit(parrots,&quot;c&quot;) %&gt;% add %&gt;% plot(main=&quot;Adding colour channels&quot;)</code></pre>
<p><img src="imager_files/figure-html/add_average_etc-1.jpeg" width="624" /></p>
<pre class="r"><code>#Use different levels of blur on the same image
blur.layers &lt;- llply(seq(1,15,l=5),function(v) isoblur(parrots,v))

blur.layers %&gt;% parmin %&gt;% plot(main=&quot;Min across blur levels&quot;)</code></pre>
<p><img src="imager_files/figure-html/add_average_etc-2.jpeg" width="624" /></p>
<pre class="r"><code>blur.layers %&gt;% parmax %&gt;% plot(main=&quot;Max across blur levels&quot;)</code></pre>
<p><img src="imager_files/figure-html/add_average_etc-3.jpeg" width="624" /></p>
<pre class="r"><code>blur.layers %&gt;% average %&gt;% plot(main=&quot;Average across blur levels&quot;)</code></pre>
<p><img src="imager_files/figure-html/add_average_etc-4.jpeg" width="624" /></p>
</div>
<div id="sub-images-pixel-neighbourhoods-etc." class="section level1">
<h1><span class="header-section-number">10</span> Sub-images, pixel neighbourhoods, etc.</h1>
<p>If you need to select a part of an image, you can use imsub, which is best explained by example:</p>
<pre class="r"><code>imsub(parrots,x &lt; 30) #Only the first 30 rows</code></pre>
<pre><code>Image. Width: 29 pix Height: 512 pix Depth: 1 Colour channels: 3 </code></pre>
<pre class="r"><code>imsub(parrots,y &lt; 30) #Only the first 30 rows</code></pre>
<pre><code>Image. Width: 768 pix Height: 29 pix Depth: 1 Colour channels: 3 </code></pre>
<pre class="r"><code>imsub(parrots,x &lt; 30,y &lt; 30) #First 30 columns and rows</code></pre>
<pre><code>Image. Width: 29 pix Height: 29 pix Depth: 1 Colour channels: 3 </code></pre>
<pre class="r"><code>imsub(parrots, sqrt(x) &gt; 8) #Can use arbitrary expressions</code></pre>
<pre><code>Image. Width: 704 pix Height: 512 pix Depth: 1 Colour channels: 3 </code></pre>
<pre class="r"><code>imsub(parrots,x &gt; height/2,y &gt; width/2)  #height and width are defined based on the image</code></pre>
<pre><code>Image. Width: 512 pix Height: 128 pix Depth: 1 Colour channels: 3 </code></pre>
<pre class="r"><code>imsub(parrots,cc==1) #Colour axis is &quot;cc&quot; not &quot;c&quot; here because &quot;c&quot; is an important R function</code></pre>
<pre><code>Image. Width: 768 pix Height: 512 pix Depth: 1 Colour channels: 1 </code></pre>
<p>Pixel neighbourhoods (for example, all nearest neighbours of pixel (x,y,z)) can be selected using stencils. See ?get.stencil and the <a href="image_statistics.html">vignette</a> on natural image statistics for more.</p>
<p>If you need to access a specific colour channel, use any of the following:</p>
<pre class="r"><code>R(parrots) </code></pre>
<pre><code>Image. Width: 768 pix Height: 512 pix Depth: 1 Colour channels: 1 </code></pre>
<pre class="r"><code>G(parrots)</code></pre>
<pre><code>Image. Width: 768 pix Height: 512 pix Depth: 1 Colour channels: 1 </code></pre>
<pre class="r"><code>B(parrots)</code></pre>
<pre><code>Image. Width: 768 pix Height: 512 pix Depth: 1 Colour channels: 1 </code></pre>
<pre class="r"><code>#R(parrots) is equivalent to channel(parrots,1)

#Set all channels to 0 except red
parrots.cp &lt;- load.example(&quot;parrots&quot;)
G(parrots.cp) &lt;- 0
B(parrots.cp) &lt;- 0
plot(parrots.cp)</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-10-1.jpeg" width="624" /></p>
<p>If you need to access a specific frame, use frame:</p>
<pre class="r"><code>frame(tennis,1)</code></pre>
<pre><code>Image. Width: 352 pix Height: 240 pix Depth: 1 Colour channels: 3 </code></pre>
<pre class="r"><code>#Blur frame 1
frame(tennis,1) &lt;- isoblur(frame(tennis,1),10)</code></pre>
<p>If you need pixel values along rows and columns use:</p>
<pre class="r"><code>imrow(R(parrots),10) %&gt;% plot(main=&quot;Red channel along 10th row&quot;,type=&quot;l&quot;)</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-12-1.jpeg" width="624" /></p>
<pre class="r"><code>imcol(B(parrots),10) %&gt;% plot(main=&quot;Blue channel along 10th line&quot;,type=&quot;l&quot;)</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-12-2.jpeg" width="624" /></p>
<p>Individual pixels can be accessed using <em>at</em> and <em>color.at</em>:</p>
<pre class="r"><code>at(parrots,x=20,y=20,cc=1:3)</code></pre>
<pre><code>[1] 0.6313725 0.5882353 0.4941176</code></pre>
<pre class="r"><code>color.at(parrots,x=20,y=20)</code></pre>
<pre><code>[1] 0.6313725 0.5882353 0.4941176</code></pre>
<p>Finally all of this is available under the familiar form of the array subset operator, which tries to save you some typing by filling in flat dimensions:</p>
<pre class="r"><code>im &lt;- imfill(4,4)
dim(im) #4 dimensional, but the last two dimensions are singletons</code></pre>
<pre><code>[1] 4 4 1 1</code></pre>
<pre class="r"><code>im[,1,,] &lt;- 1:4 #Assignment the standard way
im[,1] &lt;- 1:4 #Shortcut</code></pre>
</div>
<div id="denoising" class="section level1">
<h1><span class="header-section-number">11</span> Denoising</h1>
<p>Denoising can be performed using basic filters that average over space:</p>
<pre class="r"><code>birds &lt;- load.image(system.file(&#39;extdata/Leonardo_Birds.jpg&#39;,package=&#39;imager&#39;))
birds.noisy &lt;- (birds + 80*rnorm(prod(dim(birds)))) 
layout(t(1:2))
plot(birds.noisy,main=&quot;Original&quot;)
isoblur(birds.noisy,5) %&gt;% plot(main=&quot;Blurred&quot;)</code></pre>
<p><img src="imager_files/figure-html/denoise_blur-1.jpeg" width="624" /></p>
<p>Blurring removes some of the noise but also blurs away the contours. CImg provides an anisotropic blur that does not have that problem:</p>
<pre class="r"><code>layout(t(1:2))
plot(birds.noisy,main=&quot;Original&quot;)
blur_anisotropic(birds.noisy,ampl=1e5,sharp=1) %&gt;% plot(main=&quot;Blurred (anisotropic)&quot;)</code></pre>
<p><img src="imager_files/figure-html/denoise_aniso-1.jpeg" width="624" /></p>
</div>
<div id="colour-spaces" class="section level1">
<h1><span class="header-section-number">12</span> Colour spaces</h1>
<p>To convert from RGB to HSL/HSV/HSI/YUV/YCbCR, run RGBto[…], as in the following example:</p>
<pre class="r"><code>parrots.hsl &lt;- RGBtoHSL(parrots)
chan &lt;- channels(parrots.hsl) #Extract the channels as a list of images
names(chan) &lt;- c(&quot;H&quot;,&quot;S&quot;,&quot;L&quot;)
#Plot
layout(matrix(1:3,1,3))
l_ply(names(chan),function(nm) plot(chan[[nm]],main=nm))</code></pre>
<p><img src="imager_files/figure-html/hsl,im-1.jpeg" width="1728" /></p>
<p>The reverse operation is done by running […]toRGB. Note that all display functions assume that your image is in RGB.</p>
<pre class="r"><code>YUVtoRGB(trippy) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/trippy_is_back-1.jpeg" width="624" /></p>
<p>If you have a colour image, you convert it to grayscale using the grayscale function. If you have a grayscale image, add colour channels using add.colour:</p>
<pre class="r"><code>grayscale(parrots) %&gt;% spectrum</code></pre>
<pre><code>[1] 1</code></pre>
<pre class="r"><code>#Image has only one channel (luminance)

grayscale(parrots) %&gt;% add.colour %&gt;% spectrum</code></pre>
<pre><code>[1] 3</code></pre>
<pre class="r"><code>#Image is still in gray tones but has R,G,B channels </code></pre>
</div>
<div id="resizing-rotation-etc." class="section level1">
<h1><span class="header-section-number">13</span> Resizing, rotation, etc.</h1>
<p>Functions for resizing and rotation should be fairly intuitive:</p>
<pre class="r"><code>thmb &lt;- resize(parrots,round(width(parrots)/10),round(height(parrots)/10))
plot(thmb,main=&quot;Thumbnail&quot;) #Pixellated parrots</code></pre>
<p><img src="imager_files/figure-html/resize_rotate-1.jpeg" width="624" /></p>
<pre class="r"><code>#Same as above: negative arguments are interpreted as percentages
thmb &lt;- resize(parrots,-10,-10)

imrotate(parrots,30) %&gt;% plot(main=&quot;Rotating&quot;)</code></pre>
<p><img src="imager_files/figure-html/resize_rotate-2.jpeg" width="624" /></p>
<pre class="r"><code>imshift(parrots,40,20) %&gt;% plot(main=&quot;Shifting&quot;)</code></pre>
<p><img src="imager_files/figure-html/resize_rotate-3.jpeg" width="624" /></p>
<pre class="r"><code>imshift(parrots,100,100,boundary=1) %&gt;% plot(main=&quot;Shifting (Neumann boundaries)&quot;)</code></pre>
<p><img src="imager_files/figure-html/resize_rotate-4.jpeg" width="624" /></p>
<pre class="r"><code>imshift(parrots,100,100,boundary=2) %&gt;% plot(main=&quot;Shifting (circular)&quot;)</code></pre>
<p><img src="imager_files/figure-html/resize_rotate-5.jpeg" width="624" /></p>
<p>You can pad an image using “pad”:</p>
<pre class="r"><code>pad(parrots,axes=&quot;y&quot;,140) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/pad-1.jpeg" width="624" /></p>
<pre class="r"><code>pad(parrots,axes=&quot;y&quot;,140,pos=-1) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/pad-2.jpeg" width="624" /></p>
<p>autocrop will remove any extra padding:</p>
<pre class="r"><code>#The argument to autocrop is the colour of the background it needs to remove
pad(parrots,axes=&quot;y&quot;,140,pos=-1) %&gt;% autocrop(c(0,0,0)) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/autocrop-1.jpeg" width="624" /></p>
</div>
<div id="warping" class="section level1">
<h1><span class="header-section-number">14</span> Warping</h1>
<p>Warping maps the pixels of the input image to a different location in the output. Scaling is a special case of warping, so is shifting. Warping relies on a map: <span class="math inline">\(M(x,y) = (x&#39;,y&#39;)\)</span></p>
<p>that describes where to send pixel (x,y). Shifting the image corresponds to adding a constant to the coordinates: <span class="math inline">\(M(x,y) = (x+\delta_x,y+\delta_y)\)</span></p>
<p>In imager:</p>
<pre class="r"><code>map.shift &lt;- function(x,y) list(x=x+10,y=y+30)
imwarp(parrots,map=map.shift) %&gt;% plot</code></pre>
<p><img src="imager_files/figure-html/warp_shift-1.jpeg" width="624" /></p>
<p>The map function should take (x,y) as arguments and output a named list with values (x,y).</p>
<p>The warping algorithm has two modes, “forward” and “backward”. In forward mode you go through all <span class="math inline">\((x,y)\)</span> pixels in the source, and paint the corresponding location <span class="math inline">\(M(x,y)\)</span> in the target image. This may result in unpainted pixels, as in the following example:</p>
<pre class="r"><code>map.scale &lt;- function(x,y) list(x=1.5*x,y=1.5*y)
imwarp(parrots,map=map.scale) %&gt;% plot(main=&quot;Forward mode&quot;)</code></pre>
<p><img src="imager_files/figure-html/warp_scale_forward-1.jpeg" width="624" /></p>
<p>In backward mode you go through all pixels <span class="math inline">\((x&#39;,y&#39;)\)</span> in the target image, and look up their ancestor <span class="math inline">\(M^{-1}(x&#39;,y&#39;)\)</span> in the source image. Backward mode has no missing pixel problems, but now you need to define the inverse map and set the “direction” argument to “backward”.</p>
<pre class="r"><code>map.scale.bw &lt;- function(x,y) list(x=x/1.5,y=y/1.5)
imwarp(parrots,map=map.scale.bw,direction=&quot;backward&quot;) %&gt;% plot(main=&quot;Backward mode&quot;)</code></pre>
<p><img src="imager_files/figure-html/warp_scale_backward-1.jpeg" width="624" /></p>
<p>Of course shifting and scaling things is boring and the whole point of warping is to do things like that:</p>
<pre class="r"><code>map &lt;- function(x,y) list(x=exp(y/600)*x,y=y*exp(-sin(x/40)))
imwarp(parrots,map=map,direction=&quot;forward&quot;) %&gt;% plot()</code></pre>
<p><img src="imager_files/figure-html/warped_warp-1.jpeg" width="624" /></p>
<p>See ?imwarp for more. Note that 3D warping is possible as well.</p>
</div>
<div id="lagged-operators" class="section level1">
<h1><span class="header-section-number">15</span> Lagged operators</h1>
<p>To compute the difference between successive images in a video, you can use the shift operator:</p>
<pre class="r"><code>#Compute difference between two successive frames (at lag 1)
(imshift(tennis,delta_z=1)-tennis) %&gt;% plot(frame=2,main=&quot;Difference betw. frames 2 and 1&quot;)</code></pre>
<p><img src="imager_files/figure-html/lag-1.jpeg" width="624" /></p>
<pre class="r"><code>#Compute difference between frames (at lag 3)
(imshift(tennis,delta_z=3)-tennis) %&gt;% plot(frame=4,main=&quot;Difference between frames 3 and 1&quot;)</code></pre>
<p><img src="imager_files/figure-html/lag-2.jpeg" width="624" /></p>
<pre class="r"><code>#note that shift uses interpolation. that makes it relatively slow, but one advantage is that it allows non-integer lags:
#shift(tennis,delta_z=3.5)-tennis
#is valid</code></pre>
</div>
<div id="filtering" class="section level1">
<h1><span class="header-section-number">16</span> Filtering</h1>
<p>imager has the usual correlate and convolve operations:</p>
<pre class="r"><code>flt &lt;- as.cimg(matrix(1,4,4)) #4x4 box filter
grayscale(parrots) %&gt;% correlate(flt) %&gt;% plot(main=&quot;Filtering with box filter&quot;)</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-15-1.jpeg" width="624" /></p>
<pre class="r"><code>#Here the filter is symmetrical so convolution and correlation should be the same. Check:
a &lt;- grayscale(parrots) %&gt;% correlate(flt)
b &lt;- grayscale(parrots) %&gt;% imager::convolve(flt)
all.equal(a,b)</code></pre>
<pre><code>[1] TRUE</code></pre>
<p>CImg includes fast implementations of Gaussian (and derivative-of-Gaussian) filters. They are available via the “deriche” and “vanvliet” functions.</p>
<pre class="r"><code>im &lt;- grayscale(parrots)
layout(t(1:2))
deriche(im,sigma=4,order=2,axis=&quot;y&quot;) %&gt;% plot(main=&quot;2nd deriv of Gaussian along y&quot;)
vanvliet(im,sigma=4,order=2,axis=&quot;y&quot;) %&gt;% plot(main=&quot;2nd deriv of Gaussian along y&quot;)</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-16-1.jpeg" width="1152" /></p>
<p>The Vanvliet-Young filter is typically a better approximation. We can establish this by looking at the impulse response (which should be Gaussian). Here’s the one-dimensional case:</p>
<pre class="r"><code>n &lt;- 1e3
xv &lt;- seq(0,1,l=n) #1D Grid
imp &lt;- imdirac(c(n,1,1,1),n/2,1) #1D signal: Impulse at x = n/2
sig &lt;- 80
#impulse response of the Deriche filter
imp.dr &lt;- deriche(imp,sigma=sig) %&gt;% as.vector
#impulse response of the Vanvliet-Young filter
imp.vv &lt;- vanvliet(imp,sigma=sig) %&gt;% as.vector 
imp.true &lt;- dnorm(xv,sd=sig/n,m=.5) #True impulse response
plot(xv,imp.true/max(imp.true),type=&quot;l&quot;,lwd=2,xlab=&quot;x&quot;,ylab=&quot;Impulse response&quot;)
lines(xv,imp.vv/max(imp.vv),col=&quot;blue&quot;,lwd=2)
lines(xv,imp.dr/max(imp.dr),col=&quot;red&quot;,lwd=2)</code></pre>
<p><img src="imager_files/figure-html/unnamed-chunk-17-1.jpeg" width="624" /></p>
<p>The ideal filter is in black, the Vanvliet-Young filter in blue, the Deriche filter in red. Vanvliet-Young is clearly more accurate, but slightly slower:</p>
<pre class="r"><code>im &lt;- imfill(3e3,3e3)
system.time(deriche(im,3))</code></pre>
<pre><code>   user  system elapsed 
  0.125   0.067   0.115 </code></pre>
<pre class="r"><code>system.time(vanvliet(im,3))</code></pre>
<pre><code>   user  system elapsed 
  0.289   0.160   0.260 </code></pre>
<p>In both cases computation time is independent of filter bandwidth, which is a very nice feature (the filters are IIR).</p>
</div>
<div id="ffts-and-the-periodicsmooth-decomposition" class="section level1">
<h1><span class="header-section-number">17</span> FFTs and the periodic/smooth decomposition</h1>
<p>FFTs can be computed via the FFT function:</p>
<pre class="r"><code>im &lt;- as.cimg(function(x,y) sin(x/5)+cos(x/4)*sin(y/2),128,128)
ff &lt;- FFT(im)
plot(ff$real,main=&quot;Real part of the transform&quot;)</code></pre>
<p><img src="imager_files/figure-html/FFT-1.jpeg" width="624" /></p>
<pre class="r"><code>plot(ff$imag,main=&quot;Imaginary part of the transform&quot;)</code></pre>
<p><img src="imager_files/figure-html/FFT-2.jpeg" width="624" /></p>
<pre class="r"><code>sqrt(ff$real^2+ff$imag^2) %&gt;% plot(main=&quot;Power spectrum&quot;)</code></pre>
<p><img src="imager_files/figure-html/FFT-3.jpeg" width="624" /></p>
<p>If you want to use CImg’s FFT on images of arbitrary size you should enable FFTW3 support. Install FFTW3 on your system, then run install_github(“dahtah/imager”,ref=“fftw”). As a workaround you can also use R’s native fft:</p>
<pre class="r"><code>rff &lt;- as.matrix(im) %&gt;% fft
Re(rff) %&gt;% as.cimg %&gt;% plot(main=&quot;Real part of the transform (R&#39;s native code)&quot;)</code></pre>
<p><img src="imager_files/figure-html/FFT_nativeR-1.jpeg" width="624" /></p>
<p>Important: both FFT and fft will attempt to perform a multi-dimensional FFT of the input, with dimensionality defined by the dimensionality of the array. If you want to compute a 2D FFT for every frame of a video, use a split (imsplit or ilply).</p>
<p>The FFT works best for periodic signals. One way of making signals periodic is via zero-padding (use the pad function), another is to use the periodic-smooth decomposition of Moisan (2011):</p>
<pre class="r"><code>layout(t(1:2))
periodic.part(parrots) %&gt;% plot(main=&quot;Periodic part of parrots&quot;)
(parrots- periodic.part(parrots)) %&gt;% plot(main=&quot;Smooth residual of parrots&quot;)</code></pre>
<p><img src="imager_files/figure-html/periodicsmooth-1.jpeg" width="1152" /></p>
<p>See ?periodic.smooth for details.</p>
</div>
<div id="morphology" class="section level1">
<h1><span class="header-section-number">18</span> Morphology</h1>
<p>The following functions are available:</p>
<ul>
<li>dilate (variants: dilate_rect,dilate_square)</li>
<li>mopening,mclosing, (variants: mopening_square,mclosing_square)</li>
<li>erode (variants: erode_rect, erode_square)</li>
</ul>
<p>For image segmentation the following functions will be useful:</p>
<ul>
<li>distance_transform,watershed, label</li>
</ul>
<p>See the vignette on <a href="morphology.html">morphology</a>.</p>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
