---
title: "Imager as image editor"
output:
  html_document:
    fig_width: 6.5
    fig_height: 6
    toc: true
    number_sections: true
---

Many people will be familiar with the set of tools available in Photoshop and the Gimp (various forms of selections, brushes, erasers, etc.). Here's a screenshot of what the Gimp has to offer:

The goal of this document is to show how to do all these operations in imager. 

```{r init, echo=FALSE}
library(imager)
parrots <- load.example("parrots")

```

# Selection

## Colour picker 

This tool looks up the colour value at a certain location: in imager,

```{r}
color.at(parrots,230,30)
```

You can also try grabPoint, which is interactive. 

## Rectangular selections

To directly obtain a rectangular image subset use imsub:

```{r}
#A rectangular selection from (10,30) to (150,100)
imsub(parrots,x %inr% c(30,150),y %inr% c(10,100)) %>% plot
```

If what you need is a pixset, here's a way:

```{r}
px <- (Xc(parrots) %inr% c(30,150)) & (Yc(parrots) %inr% c(10,100))
plot(parrots)
highlight(px)
```

There's also a function to do this interactively called "grabRect". 

## Circular/elliptical selections

Use coordinates and the equation for a circle:

```{r}
plot(parrots)
px <- (Xc(parrots) - 200)^2 + (Yc(parrots) - 350)^2 < 150^2
highlight(px)
```

Similarly, you can use an elliptical equation to select an ellipse:

```{r}
plot(parrots)
px <- ((Xc(parrots) - 200)/3)^2 + (Yc(parrots) - 350)^2 < 150^2
highlight(px)
```

A change of coordinates is often useful: here we select a circle centered at the center of the image

```{r}
#Define a new coordinate system with 0 at the center of the image
Xcc <- function(im) Xc(im) - width(im)/2
Ycc <- function(im) Yc(im) - height(im)/2
px <- (Xcc(parrots)^2+Ycc(parrots)^2) < 100^2
plot(parrots)
highlight(px)
```


## Image color at a point

Use color.at:

```{r}
color.at(parrots,24,55)
```


## Selection by similarity

For grayscale images this is easy: we want the set of locations $x,y$, such that

$$ \vert I(x,y) - c \vert < \eps $$

where $c$ is our target grayscale level, and $\eps$ is a tolerance. 
We begin by computing the difference to the target:

```{r}
boats.gs <- grayscale(boats)
val <- at(boats.gs,180,216) #Grab pixel value at coord (240,220)
D <- abs(boats.gs-val) #A difference map
plot(D,main="Difference to target value")
```

The distance map can then be thresholded to yield a pixel set:

```{r}
plot(boats.gs)
highlight(D < .05) # epsilon = .05
```

Due to noise the regions may be very irregular. Better results can often be obtained using smoothing: 

```{r}
plot(boats.gs)
isoblur(boats.gs,2) %>% { abs(. - val) < .05 } %>% highlight
```

To select regions by colour similarity, the procedure is very similar, but we now need to compare values channel-by-channel and then sum:

```{r}

#Select a colour on the red coat of the right-hand parrot
cl <- color.at(parrots,598,232)

#Produces an image of the same size as "parrots"
#filled with colour "cl"
cmp <- imfill(dim=dim(parrots),val=cl)

#Blur, compare, split across channels, compute Euclidean norm
d <- isoblur(parrots,2) %>% { . - cmp } %>% imsplit("c") %>% enorm
plot(d,main="Distance map")
points(598,232,col="red")
plot(parrots)
#Select 10% most similar pixels
(!threshold(d,"10%")) %>% highlight(col="black")
```

Here's a function that does all this:

```{r}
selectSimilar <- function(im,cl,thr="auto",sigma=2)
    {
        d <- isoblur(im,sigma) %>% { . - imfill(dim=dim(im),val=cl) } %>% imsplit("c") %>% enorm
        !threshold(d,thr)
    }
plot(parrots)
selectSimilar(parrots,cl,thr="10%",sigma=5) %>% highlight(col="blue")
```

Since the selection is by similarity of colour, CIELab space is more appropriate:

```{r}
plot(parrots)
sRGBtoLab(parrots) %>%
    selectSimilar(color.at(.,330,457),thr="3%",sigma=2) %>%
    highlight(col="green")
    
parrots %>%
    selectSimilar(color.at(.,330,457),thr="3%",sigma=2) %>%
    highlight(col="red")
 
```

## Magic scissors

```{r}

magic.scissors <- function(im,ed,a,b)
    {
        ed <- channel(ed,1)
        nn <- where(ed) %>% { nabor::knn(.,t(a),k=1)$nn.idx } %>% coord.index(ed,.)
        bucketfill(ed,nn$x,nn$y,color=2)
    }

```

## Fuzzy selection (magic wand)

Flood selection selects all similar pixels around an initial point:

```{r}
plot(parrots)
px.flood(parrots,100,100,sigma=.1) %>% highlight
#Higher tolerance
px.flood(parrots,100,100,sigma=.14) %>% highlight(col="darkred")
#Different initial point
px.flood(parrots,300,100,sigma=.1) %>% highlight(col="blue")

```

# Drawing curves, text, etc. 

To draw stuff on an image you can use the base R plotting tools along with "implot". implot uses the image as canvas for an R plot, and returns an image. 
You only need to provide a piece of code that plots whatever you'd like to plot. Note that the coordinate system is the default one for images, i.e. (1...width)x(1...height). 

```{r}
#Let's add some text
parrots.mod <- implot(parrots,{ text(100,100,"ABCDEF",cex=4,col="red") })
plot(parrots.mod)

#Let's plot some random data
implot(parrots.mod,
{ points(width(parrots)*runif(50),height(parrots)*runif(50),col="darkblue",pch=24) }) %>%
    plot
```

