---
title: "Plotting a gradient field"
output:
  html_document:
    fig_width: 8.5
    fig_height: 8
    toc: true
    number_sections: true
---

[Simon Barthelm√©](http://sites.google.com/site/simonbarthelme) (GIPSA-lab, CNRS)

This example shows how to use some tools from the Hadleyverse (dplyr,tidyr and ggplot2) to visualise the gradient of an image. 

An effective way of visualising the image gradient is to see it as a vector field (a flow). At each pixel, the gradient gives a direction, which we can plot as an arrow.

The first step is to compute a gradient, using imgradient:

```{r}
library(imager)
im <- load.example("parrots") %>% grayscale %>% imresize(.3)
gr <- imgradient(im,"xy")
```

The next step is to convert the gradient to a data.frame: 

```{r message=FALSE}
library(dplyr)
names(gr) <- c("dx","dy")
dgr <- as.data.frame(gr)
head(dgr)
tail(dgr)
```

The *dx* component and *dy* components are on separate rows. For plotting it's more convenient to convert to a "wide" format: 

```{r}
dgr <- tidyr::spread(dgr,im,value)
head(dgr)
```

And we can now proceed with plotting:

```{r}
##cowplot sets better defaults for ggplot2,
##replace with library(ggplot2) if you prefer
library(cowplot)

##Subsample: take every fourth pixel
dgr.sub <- dplyr::filter(dgr,(x %% 4) ==0,(y %% 4) == 0)

#Compute end points of the arrows we'll plot, scaled so that they have a typical
#size of 1px or thereabouts
dgr.sub <- mutate(dgr.sub,xend=x+dx/sd(dx),yend=y+dy/sd(dy))

#Plot the gradient field 
p <- ggplot(dgr.sub,aes(x,y))
p <- p+geom_segment(aes(xend=xend,yend=yend),arrow = arrow(length = unit(0.01, "npc")),col="black",alpha=1)
p+scale_y_reverse()
```

The outline of the parrots is visible but things would be nicer if we could just overlay the gradient field on top of the image. Fortunately, we can: 

```{r}

p <- as.data.frame(im) %>% ggplot(aes(x,y))+geom_raster(aes(fill=value))
p <- p+geom_segment(data=dgr.sub,aes(xend=xend,yend=yend),arrow = arrow(length = unit(0.01, "npc")),col="black",alpha=1)
p+scale_y_reverse()

```

The plot is still a bit messy but we can already see how the gradient always points towards image regions with higher luminance. 
We just need an additional bit of cleaning up to get a very clear picture: 

```{r}
dgr.sub <- dplyr::mutate(dgr.sub,mag=sqrt(dx^2+dy^2), #Gradient magnitude
                         dxs=dx/mag,dys=dy/mag,#Scale every vector to unit size
                         xend = x + dxs,yend = y +dys) 
p <- as.data.frame(im) %>% ggplot(aes(x,y))+geom_raster(aes(fill=value))
p <- p+geom_segment(data=dgr.sub,aes(xend=xend,yend=yend,alpha=mag),arrow = arrow(length = unit(0.01, "npc")),col="red")
p+scale_y_reverse()+scale_fill_continuous(low="black",high="white")

```

Here's everything wrapped up in a function: 

```{r}
gradfield <- function(im,subs=4)
    {
        gr <- imgradient(im,"xy")
        names(gr) <- c("dx","dy")
        dgr <- as.data.frame(gr) %>% tidyr::spread(im,value)
        dgr <- dplyr::filter(dgr,(x %% subs) ==0,(y %% subs) == 0)
        dgr <- dplyr::mutate(dgr,mag=sqrt(dx^2+dy^2), #Gradient magnitude
                                 dxs=dx/mag,dys=dy/mag,#Scale every vector to unit size
                                 xend = x + 2*dxs,yend = y +2*dys) 
        p <- as.data.frame(im) %>% ggplot(aes(x,y))+geom_raster(aes(fill=value))
        p <- p+geom_segment(data=dgr,aes(xend=xend,yend=yend,alpha=mag),arrow = arrow(length = unit(0.01, "npc")),col="red")
        p+scale_y_reverse()+scale_fill_continuous(low="black",high="white")
    }

gradfield(grayscale(boats),6)
```

